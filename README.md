# STEP 1. 쥬스메이커 타입 정의

## 목차
  * [기간](#기간)
  * [타임라인](#타임라인)
  * [구현 내용](#구현-내용)
  * [고민했던 점](#고민했던-점)
  * [궁금한 점 / 개선한 부분](#궁금한-점-개선한-부분)
  * [브랜치 전략](#브랜치-전략)
  * [학습 키워드](#학습-키워드)

### 기간
2021.10.18(월) - 2021.10.22(금)

### 타임라인
- 월: 학습활동, 그라운드룰 작성, 개인공부(앨리-구조체, 클래스 / 조이-이니셜라이저)
- 화: nest type과 프로퍼티에 대한 학습 / 조이 - 대략적인 프로젝트 구상
- 수: 기획서 분석 / 과일의 수량을 조절하고 음료를 주문하는 기능 구현 + 개인공부
- 목: 학습활동 / pr 제출
- 금: 코드 수정 후 머지


### 구현 내용

- 과일의 재고를 관리하는 FruitStore 클래스 / 과일의 종류를 나타내는 Fruit 열거형 
- 과일쥬스를 제조하는 JuiceMaker 구조체 / 쥬스 메뉴를 나타내는 Menu 열거형 / 과일 소비량을 관리할 Recipe(name space)
- 프로젝트내에서 일어나는 모든 오류를 관리할 JuiceMakerError

### 고민했던 점

매직넘버 사용 지양
- 과일을 소비할 때 과일쥬스의 레시피를 하드코딩하지 않고 열거형으로 정리했습니다
- 매직넘버 사용을 지양하고자 Recipe 열거형에 과일 소비량의 namespace를 만들어 관리합니다

에러타입 정의
- 본 프로젝트에서 나올 수 있는 모든 에러들을 JuiceMakerError 열거형에 정의했습니다
- 또 description으로 에러메세지를 관리하고 있습니다

코드 컨벤션 준수
- 같은 성격의 변수라는것을 파악하기 쉽게 하기 위해 변수를 유사한 이름으로 맞췄습니다

<br>

## 궁금한 점 개선한 부분
1. 의미없는 return을 지향하는것  
어래 코드에서 guard 문의 파라미터를 enum으로 받고있어서 else 블럭이 실행될 일이 없다고 판단되는데,  
이런 경우에도 의미없는 리턴을 해주는 건 지양해야 할까요?

```swift
func subtractStock(of fruit: Fruit, amount: Int) {
        guard let stock = stockOfFruit[fruit] else { return } // 이 부분
        stockOfFruit[fruit] = stock - amount
    }
```

> 나중에 fruit 에 과일 목록에 없는 값을 넣으면 프로그램이 강제 종료될 수 있을 것 같습니다.  
> 항상 optional 을 바인딩할 때는 if let, guard let 을 활용해주는 것이 좋습니다.

의미없는 리턴은 지양해야한다는걸 다시 한 번 알게되었습니다.  
consumeStock 메서드에서 `guard let`을 -> `if let` 으로 바꿔주었어요!

<br>

2. 개행의 의의  
코드를 작성할 때, 개행에도 의미가 있어야한다고 하는데,  
`가독성 측면에서 개행하는 것` vs `의미를 생각해서 개행하지 않는 것` 중 어떤 방법을 택해야하는지 고민이 되었어요.
> 저는 풀어서 쓰는 것을 선호합니다.   
> 조금 더 익숙해지면 여러 줄의 코드를 한 줄로 동료들과 약속을 정해서 줄여볼 수 있겠지만  
> 회사에 들어가기 전까지는 길어지더라도 공식문서에 있는 형식으로 작성하는 것을 추천드립니다!

<br>

3. 네이밍 관련 고민  
네이밍은 항상 어려운 것 같아요.. 😅 아래 함수의 파라미터 네이밍이 적절한지에대해 이야기를 나누어 봤는데 다른 이름이 떠오르질 않습니다..!
```swift
func consumeTwoKindsOfFruits(first: Fruit, firstAmount: Int, second: Fruit, secondAmount: Int)
```
> 메소드의 네이밍 괜찮다고 생각했습니다. 조금 길어서 어색하게 생각하신 것 같은데요. 네이밍이 명확해지면 길이가 길어져도 괜찮습니다.

<br>

4. 에러타입이 정의하는 에러의 범위에 대해  
JuiceMakerError의 역할은 FruitStore에 있는 Error를 다루는 것인데요.  
만약 JuiceMakerError에서 프로젝트 내의 모든 오류를 다뤄준다고 하면, 오류처리를 위한 파일을 새로 만들어서 관리를 하는게 좋을까요?

> 열거형, 객체 등은 별도의 파일로 나눠주는 것이 좋습니다.

프로그램 전체에 대한 에러를 다루는 열거형이라면 따로 파일을 만들어서 관리하는것이 좋겠네요!  
도미닉이 말해주신대로 새로운 파일을 따로 만들어서 에러를 관리하기로 했습니다  
더불어 지금은 프로젝트가 크지 않아서 에러종류가 많지 않지만,  
프로젝트가 커지고 에러가 다양해지면 에러타입의 종류를 구분해줘도 될것같다는 생각을 헀어요  

<br>

### 브랜치 전략
- main: 완성된 프로젝트를 보관하는 브랜치
- develop: pr, 리뷰를 받고 개선한 코드를 보관하는 브랜치
- step1,2,3: 각 스텝의 요구사항을 구현하는 / 평소 코드를 작성하는 브랜치
![](https://i.imgur.com/sjYiHHr.jpg)



### 학습 키워드
CustomSTringConvertible  
enum - associated value  
namespace  
git flow  
MVC
